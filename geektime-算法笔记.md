## 树结构与算法

### 这门课能够学到的知识
- 10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树
- 10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法
- 掌握时间空间复杂度分析

### 复杂度分析
- 衡量算法好坏的标准：时间、空间复杂度分析
- 为什么需要复杂度分析：低成本的了解算法性能优越
- 方法：大 O 复杂度表示法
- 时间复杂度
    - 时间复杂度分析套路：
        - 只关注循环执行次数最多的一段代码（简单理解就是 for、while 循环体嵌套最多的地方）
        - 加法法则（多段循环体、以循环嵌套最多的为准）
        - 乘法法则 (n^嵌套层级，如两层就 n^2, 三层就 n^3...)
    - 常见时间复杂度：O(1), O(logn), O(n), O(nlogn), O(n^2), O(2^n), O(n!), O(n^k)
- 空间复杂度：与时间复杂度类型，用来描述算法的空间存储和数据规模的增长关系
- 不同情况复杂度分析
    - 复杂度分析主要分为 4 种：最好、最坏、平均、均摊
    - 平均
        - 不严谨计算：所用情况时间复杂度之和 / 所有情况
        - 加上概率：(最差情况时间复杂度) * 概率 + (其他情况时间复杂) * 概率 ... + (最差情况时间复杂度) * 概率
    - 均摊 
        - 不常用
        - 使用场景
            - 大多数情况时间复杂度不高，少数情况时间复杂度较高
            - 彼此间有前后连贯的时序关系
        - 例子
            - ArrayList 在大多数场景下 push 的时间复杂度为 O(1), 
            - 但在超出数组初始设定场景下，需要进行动态扩容，则时间复杂度为 O(n)
            - 所以需要用均摊法来分析，其时间复杂度为 O(1)


### 数组
- 定义：线性表结构。连续的内存空间，存储相同类型的数据。
- 下标随机访问高效的秘密在于，其内存连续，所以能根据寻址公式快速地得到内存地址
  - 公式：a[i]_address = base_address + i * data_type_size
  - 时间复杂度为 O(1)
- 插入、删除低效
  - 为了内存数据连续，每次操作都要搬移数据，除了最后一个
  - 复杂度为: 最快 O(1), 最差 O(n)，平均 O(n)
- 优化：
  - 插入，数据直接插入待插入位置，原位置数据放到末尾，时间复杂度 O(1)
  - 删除，使用标记法标记待删除数据，已达到均摊时间复杂度为 O(1)


### 链表
#### 链表基础
- 缓存：软件优化常见手段
  - FIFO：先进先出
  - LFU：最少使用策略
  - LRU：最近最少使用策略
- 链表基础
  - 内存友好：不需要连续的内存
  - 单链表、双向链表、循环链表
  - 插入 O(1), 删除 O(1), 查找 O(n)
- 分类：
  - 单链表：节点上有数据、后继指针
  - 双向链表：有数据、前继指针、后继指针
  - 循环链表：跟单链表区别是会首尾相连
  - 双向循环链表
- 链表 LRU 实现
  1. 如果待访问节点存在，这把节点移到链表头部
  2. 如果节点不存在
     1. 链表已满，则从链表尾部删除最久节点后再插入
     2. 未满，则直接插入到首部

#### 链表技巧
- 手熟尔：反转链表、合并有序链表
1. 指针/引用：存储指向对象的内存地址
2. 防止指针丢失和内存泄漏
  - 在插入节点时，需要注意把上个节点的 next 缓存起来
3. 利用哨兵节点来优化链表操作难度
4. 重点留意边界条件
5. 画图辅助思考
6. 多练多写
  - 单链表反转
  - 链表环检测
  - 合并有序链表
  - 删除链表倒数第 n 个节点
  - 求链表中间节点


#### 递归
- 递归步骤
  - 分解子问题，子问题与问题类似
  - 递归终止条件
- 防止堆栈溢出
  - 使用迭代
  - 尾递归优化


### 排序上
- 分析排序算法
  - 算法执行效率
    - 最好、最坏和平均时间复杂度
    - 关注时间复杂度的系数、常数和低阶
    - 比较次数和交换次数
  - 算法内存消耗
    - 空间复杂度
    - 原地排序。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法
  - 排序算法的稳定性
    - 如果待排序两个值排序后位置不变，排序算法就是稳定的
- 冒泡排序
  - 原地排序
  - 稳定排序
  - 时间复杂度 O(n^2)
- 插入排序
  - 思想：区分已排序和未排序区, 从未排序区间取值，到排序区间里面进行比较
  - 原地排序
  - 稳定排序
  - 时间复杂度 O(n^2)
- 选择排序
  - 思想：区分已排序和未排序区来，从未排序区间中去最大/小值，放到排序区间中
  - 原地排序
  - 稳定排序
  - 时间复杂度 O(n^2)


### 排序下
- 归并排序
  - 原理：分而治之
  - 该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。（分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。
  - 时间复杂度： O(nlogn)
  - 空间复杂度：O(n)
- 快速排序  
  - 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。
  - 时间复杂度：O(nlogn), 最坏 O(n^2)
  - 空间复杂度:O(logn)（递归调用消耗

### 线性排序
- 桶排序(数据非常大，内存放不下)
  - 核心思想：将要排序的数据分别放到有序的桶里面，再在每个桶里面单独进行排序
  - 限制：
    - 要很容易划分出 m 个桶，且桶间要有顺序关系
    - 桶内数据要分布均匀
  - 使用场景：外部排序，即数据量较大，需要把数据放到硬盘中
- 计数排序
  - 计数排序是桶排序的特殊情况
  - 限制条件
    - 只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了
    - 计数排序只能给非负整数排序
- 基数排序
  - 条件
    - 需要可以分割出独立的“位”来比较
    - 而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了
    - 每一位的数据范围不能太大，要可以用线性排序算法来排序


### Trie 树
- 什么是 Trie 树
  - 字典树，用来快速查找字符串的数据结构
  - 本质是共享字符串的公共前缀
- 实现 Trie 树
  - Trie Node，包含当前数据，已经下一个前缀字符的集合
  - 插入：
    - 遍历待插入字符串，如果当前字符不在 Trie Node 上，则创建并插入。
    - 如果在则进入子节点继续判断，知道遍历完待插入字符串
  - 查找
    - 遍历待查找字符串，如果当前字符不在 Trie 中，则不存在该 Trie 树种
    - 否则进入子节点继续遍历查找下一个字符
- 时空复杂度
  - 时间复杂度：
    - 构建为 O(n), n 为需要扫描的所有字符串，
    - 查找为 O(k), k 为待查找字符串长度
  - 空间复杂度
    - 耗内存，每个节点都要包含可能的字符
    - 优化：可以使用有序数组、跳板、散列表、红黑树来包含可能字符
- 与其他数据结构比较：不适合精确查找，可用散列表、红黑树替代


### 图
- 基础概念
  - 更复杂的非线性数据结构
  - 顶点和边：顶点相当于树的节点，顶点之间使用边来建立连接
  - 度（degree）：顶点上有多少条边
  - 有向图和无向图：边带有方向则为有向图，无方向则为无向图
  - 入度（in-degree）：有向图中有多少边指向该顶点
  - 出度（out-degree）：有向图中有多少边是以该顶点为起点指向其他顶点
  - 有权图：每条边都有权重值
- 邻接矩阵
  - 无向图：i,j 右边，则 A[i][j]、A[j][i] 为 1
  - 有向图：i 指向 j， 则 A[i][j] 为 1
  - 带权图：则数组中存储对应的权重
  - 优点：
    - 存储简单直接，查找高效
    - 方便计算
      - 将图的运算转换成矩阵的计算
      - [Floyd-Warshall 算法](https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95) 解决最短路劲问题
  - 缺点：浪费空间
    - 微信有几亿用户，但每个人的好友大部分是几百，用邻接矩阵会浪费大量空间
- 邻接表
  - 使用哈希表的方式存储，顶点存在数组中，与顶点相连的点存在链表中（也可以用平衡树、有序数组等提高提高查找速度）
  - 优点：节省空间
  - 缺点：查找慢


### 广度优先搜索和深度优先搜索
- 搜索算法包括：广度优先搜索、深度优先搜索、A*、IDA* 搜索算法
- 广度优先搜索
- 深度优先搜索（BFS）
  - 层层推进搜索，就近原则
  - 使用队列来进行广度优先搜索
- 深度优先搜索（DFS）
  - 使用栈来进行深度优先搜索


### 贪心算法（greedy algorithm）
- 理解贪心算法
  - 背包问题
  - 贪心算法解决步骤
    1. 经典场景：针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大
    2. 看是否能用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。
    3. 结果是否最优：前面的选择会影响后面的选择，则不适合贪心算法
- 实例
  - 分糖果
    - 找糖果大小需求最小的孩子，并把最小最符合需求的糖果给他
  - 钱币找零
    - 尽可能用最大面值来找零
  - 区间覆盖
  - 霍夫曼编码
    - 把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码
    - 各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况
    - 任何一个字符的编码都不是另一个的前缀，在解压缩的时候，我们每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义


### 理解分治算法
- 理解分治算
  - 将问题分解成规模更小的相似子问题进行求解，之后再合并
  - 步骤：分解、解决、合并
  - 条件
    - 原问题和子问题相似
    - 子问题间相互独立
    - 有终止条件
    - 子问题可以合并成原问题，且代价不大
- 应用分析
  - 排序算法中用分治法来分析有序度和逆序度
  - 分治法在海量数据中的应用

### 回溯算法
- 理解回溯算法
  - 回溯算法经常用在搜索问题上
  - 回溯算法就是枚举所有可能，遇到分支时选择其中一条，查找到底时回到分叉口，选择另一个分支继续查找
  - 经典例子：八皇后问题
    - 把问题分成八个阶段，在每个阶段中找到满足条件的解，然后进入下个阶段，直到结束
- 两个经典回溯算法
  - 0-1 背包问题
  - 正则表达式


### 初识动态规划
- 动态规划学习路线
  - 动态规划适合用来求解最优问题
  - 路径
    - 为什么需要动态规划
    - 动态规划思路
    - 动态规划实战
- 0-1 背包问题
  - 递归：回溯方法解决，问题演化成递归树，时间复杂度指数爆炸
  - 重复子问题：使用备忘录来避免冗余，常用二维数组存储
  - 最优子结构：状态转移方程
  - 自底向上：递归转为迭代


### 最短路径 Dijkstra
- 最短路径算法解析
  - 解决最短路径问题可以使用 Dijkstra 算法
  - 特点：以起点为中心向外扩山（广度优先搜索），知道终点为止
- Dijkstra 算法应用
  - 在大的数据地图中，无法直接使用 Dijkstra 算法，可以先在小区块中算出最短路径
  - 大数据地图中算出较远的点的最短路径，可以只关心关键节点，这样数据量就少
  - 算最短时间可以将时间作为权重
  - 算红绿灯可以直接使用广度优先搜索

### A* 搜索算法
- 是 Dijkstra 算法的优化，用来快速找出一条接近于最短路线的次优路线
- 与 Dijstra 区别
  - 优先级队列构建的方式不同。
  - A* 算法在更新顶点 dist 值的时候，会同步更新 f 值
  - 循环结束的条件也不一样。Dijkstra 算法是在终点出队列的时候才结束，A* 算法是一旦遍历到终点就结束。
- 思想不同
  - A* 算法是使用贪心的方式，来选择每段路径的最优，直到找到重点
  - 而 Dijkstra 是用动态规划的方式，找出所有最短路径，并选择其中最优路径