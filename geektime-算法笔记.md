## 树结构与算法

### 这门课能够学到的知识
- 10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树
- 10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法
- 掌握时间空间复杂度分析

### 复杂度分析
- 衡量算法好坏的标准：时间、空间复杂度分析
- 为什么需要复杂度分析：低成本的了解算法性能优越
- 方法：大 O 复杂度表示法
- 时间复杂度
    - 时间复杂度分析套路：
        - 只关注循环执行次数最多的一段代码（简单理解就是 for、while 循环体嵌套最多的地方）
        - 加法法则（多段循环体、以循环嵌套最多的为准）
        - 乘法法则 (n^嵌套层级，如两层就 n^2, 三层就 n^3...)
    - 常见时间复杂度：O(1), O(logn), O(n), O(nlogn), O(n^2), O(2^n), O(n!), O(n^k)
- 空间复杂度：与时间复杂度类型，用来描述算法的空间存储和数据规模的增长关系
- 不同情况复杂度分析
    - 复杂度分析主要分为 4 种：最好、最坏、平均、均摊
    - 平均
        - 不严谨计算：所用情况时间复杂度之和 / 所有情况
        - 加上概率：(最差情况时间复杂度) * 概率 + (其他情况时间复杂) * 概率 ... + (最差情况时间复杂度) * 概率
    - 均摊 
        - 不常用
        - 使用场景
            - 大多数情况时间复杂度不高，少数情况时间复杂度较高
            - 彼此间有前后连贯的时序关系
        - 例子
            - ArrayList 在大多数场景下 push 的时间复杂度为 O(1), 
            - 但在超出数组初始设定场景下，需要进行动态扩容，则时间复杂度为 O(n)
            - 所以需要用均摊法来分析，其时间复杂度为 O(1)


### 数组
- 定义：线性表结构。连续的内存空间，存储相同类型的数据。
- 下标随机访问高效的秘密在于，其内存连续，所以能根据寻址公式快速地得到内存地址
  - 公式：a[i]_address = base_address + i * data_type_size
  - 时间复杂度为 O(1)
- 插入、删除低效
  - 为了内存数据连续，每次操作都要搬移数据，除了最后一个
  - 复杂度为: 最快 O(1), 最差 O(n)，平均 O(n)
- 优化：
  - 插入，数据直接插入待插入位置，原位置数据放到末尾，时间复杂度 O(1)
  - 删除，使用标记法标记待删除数据，已达到均摊时间复杂度为 O(1)


### 链表
#### 链表基础
- 缓存：软件优化常见手段
  - FIFO：先进先出
  - LFU：最少使用策略
  - LRU：最近最少使用策略
- 链表基础
  - 内存友好：不需要连续的内存
  - 单链表、双向链表、循环链表
  - 插入 O(1), 删除 O(1), 查找 O(n)
- 分类：
  - 单链表：节点上有数据、后继指针
  - 双向链表：有数据、前继指针、后继指针
  - 循环链表：跟单链表区别是会首尾相连
  - 双向循环链表
- 链表 LRU 实现
  1. 如果待访问节点存在，这把节点移到链表头部
  2. 如果节点不存在
     1. 链表已满，则从链表尾部删除最久节点后再插入
     2. 未满，则直接插入到首部

#### 链表技巧
- 手熟尔：反转链表、合并有序链表
1. 指针/引用：存储指向对象的内存地址
2. 防止指针丢失和内存泄漏
  - 在插入节点时，需要注意把上个节点的 next 缓存起来
3. 利用哨兵节点来优化链表操作难度
4. 重点留意边界条件
5. 画图辅助思考
6. 多练多写
  - 单链表反转
  - 链表环检测
  - 合并有序链表
  - 删除链表倒数第 n 个节点
  - 求链表中间节点


#### 递归
- 递归步骤
  - 分解子问题，子问题与问题类似
  - 递归终止条件
- 防止堆栈溢出
  - 使用迭代
  - 尾递归优化


### 排序上
- 分析排序算法
  - 算法执行效率
    - 最好、最坏和平均时间复杂度
    - 关注时间复杂度的系数、常数和低阶
    - 比较次数和交换次数
  - 算法内存消耗
    - 空间复杂度
    - 原地排序。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法
  - 排序算法的稳定性
    - 如果待排序两个值排序后位置不变，排序算法就是稳定的
- 冒泡排序
  - 原地排序
  - 稳定排序
  - 时间复杂度 O(n^2)
- 插入排序
  - 思想：区分已排序和未排序区, 从未排序区间取值，到排序区间里面进行比较
  - 原地排序
  - 稳定排序
  - 时间复杂度 O(n^2)
- 选择排序
  - 思想：区分已排序和未排序区来，从未排序区间中去最大/小值，放到排序区间中
  - 原地排序
  - 稳定排序
  - 时间复杂度 O(n^2)


### 排序下
- 归并排序
  - 原理：分而治之
  - 该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。（分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。
  - 时间复杂度： O(nlogn)
  - 空间复杂度：O(n)
- 快速排序  
  - 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。
  - 时间复杂度：O(nlogn), 最坏 O(n^2)
  - 空间复杂度:O(logn)（递归调用消耗

### 线性排序
- 桶排序(数据非常大，内存放不下)
  - 核心思想：将要排序的数据分别放到有序的桶里面，再在每个桶里面单独进行排序
  - 限制：
    - 要很容易划分出 m 个桶，且桶间要有顺序关系
    - 桶内数据要分布均匀
  - 使用场景：外部排序，即数据量较大，需要把数据放到硬盘中
- 计数排序
  - 计数排序是桶排序的特殊情况
  - 限制条件
    - 只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了
    - 计数排序只能给非负整数排序
- 基数排序
  - 条件
    - 需要可以分割出独立的“位”来比较
    - 而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了
    - 每一位的数据范围不能太大，要可以用线性排序算法来排序