## 原型对象概述

### 构造函数的缺点
在 JavaScript 中，我们可以使用构造函数将一些重复的行为封装起来，实例化成一个个对象。但构造函数有一个缺点，就是每一个实例对象的属性和方法都是独立互补影响的，这就使得相同功能的方法，在两个实例对象里面创建了两次，浪费了大量内存。
```js
function Foo(name) {
    this.foo = name
    this.walk = function walk() {
        console.log(walk)
    }
}

let foo1 = new Foo('foo1')
let foo2 = new Foo('foo2')
console.log(foo1.walk === foo2.walk) // false, 创建了两个 walk 方法，浪费内存
```

### 原型对象 prototype
由于相同功能的方法并不需要创建两遍，所以就出现了原型对象。每一个函数中都会有 prototype 这个属性，它是一个对象。对于普通的函数它并没有太大的作用，但在构造函数中它却是实现属性和方法共享的关键。
```js
function Foo() {}
Foo.prototype.walk = function() {
    console.log('walk')
}

let foo1 = new Foo('foo1')
let foo2 = new Foo('foo2')

console.log(typeof Foo.prototype)  // object 是一个对象
console.log(foo1.walk === foo2.walk) // true 指向同一个内存
```

需要注意的是，如果实例对象上已经有了这个属性和方法，则实现对象不会去使用原型对象上的属性和方法。
```js
function Foo() {}
Foo.prototype.name = 'Foo'

let foo1 = new Foo()
foo1.name = 'foo1'

console.log(foo1.name) // foo1
```

### 原型链
1. 每一个对象上都有原型属性 prototype
2. 每个对象都能作为原型属性
3. 因为原型属性 prototype 也是对象，所以原型上也有原型

综上就行形成了一条原型链：对象上的原型，原型上的原型。。。

那这里就衍生出一个问题，原型链有尽头吗？答案是有的。因为每个函数的原型都是对象，所以它们都是由内置的构造函数 Object 创建的，而 Object 的 prototype 为 null。null 没有属性和方法，所以也就没有了原型属性。所以 null 就行原型链的尽头。
```js
Object.getPrototypeOf(Object.prototype) // null
```

### constructor 属性
原型对象上有一个 constructor 属性，该属性指向原型所在的构造函数。由于实例对象拥有原型上所有的属性和方法，所以也就拥有了 constructor 属性。
```js
function Foo() {}
let foo1 = new Foo() {}

foo1.constructor === Foo.prototype.constructor // true
```

constructor 属性除了能让我们知道实例对象是由哪个构造函数创建的，也能让实例对象拥有创造新对象的能力。(我们也可以通过 constructor.name 来获取构造函数的名称)
```js
function Foo() {}
let foo1 = new Foo() {}

let fooCopy = new foo1.constructor() // 创建新对象

console.log(foo.constructor.name) // 'Foo'
```

constructor 属性表示原型对象和构造函数之间的关联关系。所以一般修改原型对象时，也会同时修改 constructor 属性。
```js
function Foo() {}

Foo.prototype.constructor === Foo // true

Foo.prototype = {
    a: 'a'
}
Foo.prototype.constructor === Foo // false
Foo.prototype.constructor === Object // true
```

上述代码可知，Foo 的原型对象指向了一个普通对象，而由于这个普通对象的 constructor 是 Object。所以如果后面我们用这个 Foo 来创建新的实例时，我们就没法通过 constructor 知道是哪个构造函数创建的了。因此正确的修改原型的方式应该是：
```js
function Foo() {}

Foo.prototype = {
    constructor: Foo,
    a: 'a'
}

// or

Foo.prototype.a = 1
```



